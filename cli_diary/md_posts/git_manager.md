---
title: git_manager
mainfont: Iosevka
---


I've been thinking for some time in ways to automate the git uploading process.  
I have eighteen repositories now and it's getting harder to track down their state.  
I wanted something that would automate the repetitive parts, (init, the commit then push...) and that was aware of their update needs.   
So, I thought of this:  

1. First create a dictionary with names and urls of all the repositories and keep it in a file:  
```python
"""Dictionary with lists of my git projects"""


def repo_list():
    repo_list.dict = {
        "bkmks": "/home/mic/python/bkmk",
        "urwid": "/home/mic/python/bkmks_urwid",
        "books": "/home/mic/python/books",
        "cli_app": "/home/mic/python/cli_app_list",
        "micro_diary": "/home/mic/python/micro_diary",
        "notes": "/home/mic/python/notes",
        "old_projects": "/home/mic/python/old_alternative_projects",
        "player": "/home/mic/python/player",
        "pwd": "/home/mic/python/pwd",
        "rss": "/home/mic/python/rss",
        "scraper": "/home/mic/python/scraper",
        "todos": "/home/mic/python/todos",
        "tree": "/home/mic/python/tree",
        "urlshort": "/home/mic/python/urlshort",
        "scripts": "/home/mic/scripts",
        "python_blog": "/home/mic/hexo-python-blog",
        "hexo-poems": "/home/mic/hexo-poems",
        "site": "/srv/http",
    }

    return repo_list.dict


if __name__ == "__main__":
    repo_list()
```

2. Now we will test all repositories to know if they need updating, by going in their directories and typing the command "git status". We convert the function object in a dictionary so as to be simple to handle.  
We iterate through a loop for all the values of the dictionary, go to their location and do 'git status'. We collect the output to a file. I used a bash expression so as to be able to use the git command "git status". The '$()' is the format for commands in bash.  I used the expression '&>' instead of only '>', to write to a file because the ampersand diverts standard error as the '>' diverts output. 'cwd' means 'current working directory' and determines where the subprocess command will take place.  

```python
def repositories():
    """Here we harvest a 'git status' of all the repositories"""
    repositories.repos = repo_list()
    for value in repositories.repos.values():
        cmd = "echo $(git status) &> status_results.txt"
        subprocess.run(cmd, cwd=value, shell=True)


if __name__ == "__main__":
    repositories()
```
3. Again we iterate through the list of values of our dictionary to find the files with the answers to our former query. We open them and if the strings "Changes no staged for commit" and "Untracked files" are present, we put them in a list of repositories to update.  

```python
def update():
    """Here we verify who needs an update"""
    update.lst = []
    for value in repositories.repos.values():
        path = value + "/status_results.txt"
        with open(path, "r") as f:
            status_content = f.read()
        if "Changes not staged for commit" or "Untracked files" in status_content:
            update.lst.append(path)


if __name__ == "__main__":
    update()
```

4. And, at last, we iterate through a list of dictionary items, (key:value), and if we find the path in the list of repositories to update, we take it's name and put it in a list.
To update the repositories it was needed to create specific scripts for each repo, and this is because I used [Autoexpect](https://linux.die.net/man/1/autoexpect) to create them. Autoexpect 'films' us doing a given set of commands and operations and repeats them when called out to. It's particularly useful when having scripts that need authentication.  
Here's and example of one of the scripts:  
```
#!/usr/bin/expect -f
#
# This Expect script was generated by autoexpect on Wed Aug 11 18:18:48 2021
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			 ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don


set timeout -1
spawn $env(SHELL)
match_max 100000
expect -exact "[1m[7m#[27m[1m[0m                              \r \r\r[0m[27m[24m[Jmicaldas# [K[?2004h"
send -- "gi"
expect -exact gi"
send -- "t add .\r"
expect -exact "[?2004l\r\r
[1m[7m#[27m[1m[0m               \r \r\r[0m[27m[24m[Jmicaldas# [K[?2004h"
send -- "gi"
expect -exact gi"
send -- "t commit -m \"Nth commit\"\r"
expect -exact "[?2004l\r\r
\[master e2c3369\] Nth commit\r
 2 files changed, 1 insertion(+)\r
 create mode 100755 script.exp\r
 create mode 100644 status_results.txt\r
[1m[7m#[27m[1m[0m               \r \r\r[0m[27m[24m[Jmicaldas# [K[?2004h"
send -- "gi"
expect -exact gi"
send -- "t push origin master\r"
expect -exact "[?2004l\r\r
fatal: 'origin' does not appear to be a git repository\r
fatal: Could not read from remote repository.\r
\r
Please make sure you have the correct access rights\r
and the repository exists.\r
[1m[7m#[27m[1m[0m               \r \r\r[0m[27m[24m[Jmicaldas# [K[?2004h"
send -- "[A"
expect -exact "git push origin master"
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "[D"
expect -exact "
send -- "_"
expect -exact "_"master
send -- "g"
expect -exact "g"master
send -- "o"
expect -exact "o"master
send -- "g"
expect -exact "g"master
send -- "s"
expect -exact "s"master
send -- "\r"
expect -exact "[?2004l\r\r
Enumerating objects: 5, done.\r
Counting objects:  20% (1/5)\rCounting objects:  40% (2/5)\rCounting objects:  60% (3/5)\rCounting objects:  80% (4/5)\rCounting objects: 100% (5/5)\rCounting objects: 100% (5/5), done.\r
Delta compression using up to 8 threads\r
Compressing objects:  33% (1/3)\rCompressing objects:  66% (2/3)\rCompressing objects: 100% (3/3)\rCompressing objects: 100% (3/3), done.\r
Writing objects:  25% (1/4)\rWriting objects:  50% (2/4)\rWriting objects:  75% (3/4)\rWriting objects: 100% (4/4)\rWriting objects: 100% (4/4), 486 bytes | 486.00 KiB/s, done.\r
Total 4 (delta 0), reused 0 (delta 0), pack-reused 0\r
Username for 'http://localhost:3000': "
send -- "mic\r"
expect -exact "mic\r
Password for 'http://mic@localhost:3000': "
send -- "xxxx\r"
expect -exact "\r
To http://localhost:3000/mic/tree.git\r
   5bd1295..e2c3369  master -> master\r
[1m[7m#[27m[1m[0m               \r \r\r[0m[27m[24m[Jmicaldas# [K[?2004h"
send -- ""
expect eof
```

Getting back to the python document. For each name that we find in our list of paths to repos that needed updating, write the url to the bash script that'll do the job, and run it with subprocess.  
```python
def final_update():
    "Here we proceed at the actual update"
    names = []
    for name, path in repositories.repos.items():
        if path in update.lst:
            names.append(name)

    for name in names:
        cmd = "/home/mic/scripts/git_manager/" + name + ".exp"
        subprocess.run(cmd, shell=True)
```
Here's the final document:

```python
"""This function checks if the output says that is needed to update the repository"""
import os
import subprocess
from loguru import logger
from dic import repo_list

fmt = "{time} - {name} - {level} - {message}"
logger.add("spam.log", level="DEBUG", format=fmt)
logger.add("error.log", level="ERROR", format=fmt)


def repositories():
    """Here we harvest a 'git status' of all the repositories"""
    repositories.repos = repo_list()
    for value in repositories.repos.values():
        cmd = "echo $(git status) &> status_results.txt"
        subprocess.run(cmd, cwd=value, shell=True)


if __name__ == "__main__":
    repositories()


def update():
    """Here we verify who needs an update"""
    update.lst = []
    for value in repositories.repos.values():
        path = value + "/status_results.txt"
        with open(path, "r") as f:
            status_content = f.read()
        if "Changes not staged for commit" or "Untracked files" in status_content:
            update.lst.append(path)


if __name__ == "__main__":
    update()


def final_update():
    "Here we proceed at the actual update"
    names = []
    for name, path in repositories.repos.items():
        if path in update.lst:
            names.append(name)

    for name in names:
        cmd = "/home/mic/scripts/git_manager/" + name + ".exp"
        subprocess.run(cmd, shell=True)


if __name__ == "__main__":
    final_update()
```

----------------------------------------------------------------------------

## UPDATE
Apparently I was hasty giving this module as terminated. I assumed that the Expect scripts would work as expected, and didn't took the time to test them. Which is a particularly egregious mistake as they are numerous. A lot of work could have been spared if I just took the sensible precaution to see if the scripts were doing what they were supposed to do.  
The problem, to add insult to injury, is very quickly diagnosed. Take the former Expect script example: when I do  a 'git commit', Expect 'expects' that the result of the commit is, _ipsis verbis_, equal to the one that was done when 'recording' the script:

```
send -- "t commit -m \"Nth commit\"\r"
expect -exact "[?2004l\r\r
\[master e2c3369\] Nth commit\r
 2 files changed, 1 insertion(+)\r
 ```

 Obviously when the script runs a second time, this does not happen and it stops, not knowing what to do.  
 There is a way around this, and it's to use Expect as was originally intended, as a coding language, and write how you want it to react. Not just putting it 'recording' blindly your actions.  
 The problem with this is that the language is both ancient and hard. But I'm somewhat committed to making this work, so I won't quit just now.  
 Asides from that, I made several changes to the code, that seemed excessively complex to me, to reach, I expected, a cleaner, simpler version.  
 But now, looking at it, it seems that my attempts to simplify made it hopelessly convoluted.  
 I seem to remember that these changes were done because the code was not working, asides from the Expect problem, and hence the necessity of this added complexity.   
 But, to be honest, I really don't remember if my recollection is correct.  
 As I'm questioning this code, what I'll do now is comment it and see if by retracing my steps this makes more sense. If not, I'll change it as I write this.  
 The first thing I would like to get out of the way is the 'logger' statements. These are logging commands for [Loguru](https://loguru.readthedocs.io/en/stable/overview.html). The '@logger.catch' decorator collects all error messages produced by a specific function. The other logger statements are generally to let me visualize the state of a variable in a particular moment in time. It's like 'print' but it doesn't necessarily goes to standard output.  
 1. First thing I did was bring to the main file the repos list and turn it in a dictionary in global setting, so it can be used by all functions.  

 ```python
repo_dict = {
    "bkmks": "/home/mic/python/bkmk",
    "bkmks_urwid": "/home/mic/python/bkmks_urwid",
    "books": "/home/mic/python/books",
    "cli_app_list": "/home/mic/python/cli_app_list",
    "micro_diary": "/home/mic/python/micro_diary",
    "notes": "/home/mic/python/notes",
    "old_alternative_projects": "/home/mic/python/old_alternative_projects",
    "player": "/home/mic/python/player",
    "pwd": "/home/mic/python/pwd",
    "rss": "/home/mic/python/rss",
    "scraper": "/home/mic/python/scraper",
    "scripts": "/home/mic/scripts",
    "todos": "/home/mic/python/todos",
    "tree": "/home/mic/python/tree",
    "url": "/home/mic/python/urlshort",
    "hexo-python-blog": "/home/mic/hexo-python-blog",
    "hexo_poems": "/home/mic/hexo-poems",
    "http": "/srv/http",
}
 ```

2. The first function verifies what repos need an update.  
We create a loop that runs through the paths to repos in said dictionary, and adds to them the name of the file that will be created when we run the 'git status' command through all repositories. This new list with the updated URLs, is called 'paths'.  
```python
    logger.info(repo_dict)
    for value in repo_dict.values():
        path.append(value + "/status_results.txt")
    logger.info(path)
```
3. Now we look to the paths in the 'path' list, and check for the patterns that'll tell us if its necessary to update the repo or not. These patterns are:
 * 'Changes not staged for commit',
 * 'Untracked files'.  
If we find these patterns in the file with the output of the 'git status' command, we append the URLs to a new list called 'repositories.lst'.  
From that list we take out only the repository names, with the [rsplit](https://www.w3schools.com/python/ref_string_rsplit.asp) method, that splits a string to a list. We define that we want only the penultimate value (-2), counted if we split the string by '/'. This list will have only the repo names that need updating.  
```python
    for i in path:
        if "Changes not staged for commit" or "Untracked files" in i:
            repositories.lst.append(i)
    logger.info(repositories.lst)
    for i in repositories.lst:
        repositories.chaves.append(i.rsplit("/")[-2])
    logger.info(repositories.chaves)
```
4. As there is one Expect script per repository, we build a string URL that is composed of the path to these scripts, plus the repo names to update, that we take from repositories.chaves. As they are bash scripts, it's necessary to use subprocess.  
```python


@logger.catch
def update():
    "Here we do the update"
    for i in repositories.chaves:
        cmd = "/home/mic/scripts/git_manager/" + i + ".exp"
        subprocess.run(cmd, shell=True)

    logger.info(cmd)
```

Of course that even with these changes the script still doesn't work. It needs the Expect scripts working correctly.  
But,  
while writing this,  
I corrected a lot of 'corrections' I did to the original version; that weren't corrections at all, but added confusion, written when my brain was in a particularly foggy state.  
Expect another update when I solve the Expect problem. I hope it's soon.  
Here is the updated file:  
```python
import os
import subprocess
import time
from loguru import logger


fmt = "{time} - {name} - {level} - {message}"
logger.add("logging/spam.log", level="DEBUG", format=fmt, backtrace=True, diagnose=True)
logger.add("logging/error.log", level="ERROR", format=fmt, backtrace=True, diagnose=True)
logger.add("logging/info.log", level="INFO", format=fmt, backtrace=True, diagnose=True)

repo_dict = {
    "bkmks": "/home/mic/python/bkmk",
    "bkmks_urwid": "/home/mic/python/bkmks_urwid",
    "books": "/home/mic/python/books",
    "cli_app_list": "/home/mic/python/cli_app_list",
    "micro_diary": "/home/mic/python/micro_diary",
    "notes": "/home/mic/python/notes",
    "old_alternative_projects": "/home/mic/python/old_alternative_projects",
    "player": "/home/mic/python/player",
    "pwd": "/home/mic/python/pwd",
    "rss": "/home/mic/python/rss",
    "scraper": "/home/mic/python/scraper",
    "scripts": "/home/mic/scripts",
    "todos": "/home/mic/python/todos",
    "tree": "/home/mic/python/tree",
    "url": "/home/mic/python/urlshort",
    "hexo-python-blog": "/home/mic/hexo-python-blog",
    "hexo_poems": "/home/mic/hexo-poems",
    "http": "/srv/http",
}


@logger.catch
def repositories():
    """Verify what repos need an update"""
    repositories.lst = []
    path = []
    repositories.chaves = []

    logger.info(repo_dict)
    for value in repo_dict.values():
        path.append(value + "/status_results.txt")
    logger.info(path)

    for i in path:
        if "Changes not staged for commit" or "Untracked files" in i:
            repositories.lst.append(i)
    logger.info(repositories.lst)
    for i in repositories.lst:
        repositories.chaves.append(i.rsplit("/")[-2])
    logger.info(repositories.chaves)


if __name__ == "__main__":
    repositories()


@logger.catch
def update():
    "Here we do the update"
    for i in repositories.chaves:
        cmd = "/home/mic/scripts/git_manager/" + i + ".exp"
        subprocess.run(cmd, shell=True)

    logger.info(cmd)


if __name__ == "__main__":
    update()
```
